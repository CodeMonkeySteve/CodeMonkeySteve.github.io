<p>The first thing you need to understand for this to make sense is that the magic of <span class="caps">OFF</span> is all in the <a href="http://wiki.offdev.org/Technical_Overview_of_OFF">block encoding</a> which turns meaningful bits into ownerless, quasi-random blocks identified by their SHA1 hashes.  Once this transformation is performed, there is no way for anyone to know the content of a block on the network, as it has no meaning until it&#8217;s combined with other blocks (and, in that way, may actually &#8220;belong&#8221; to multiple files, simultaneously).</p>
<p>The thing that first screamed &#8220;Rails app!&#8221; to me is the fact that, once the content has been <span class="caps">OFF</span>-encoded into blocks, any transport mechanism can be used to move these blocks around, allowing for a network-agnostic peer-to-peer system.  Using <span class="caps">HTTP</span>, I could write my own smart, caching web peer (with combined web UI) in Rails, but since it&#8217;s using <span class="caps">HTTP</span>, I could also use dumb web server file servers as mass block stores (no <span class="caps">CGI</span> required!).  Eventually, I could add (trivial) support to talk to the existing <span class="caps">OFF</span> network (also <span class="caps">HTTP</span>, <span class="caps">AFAIK</span>). If I watned to get really crazy, I could make the app a 3-way network bridge with BitTorrent (which also uses SHA1-identified data blocks).</p>
<p>This is an extension of earlier musings about extending <span class="caps">HTTP</span> (or coming up with some other standard) for enumerating mirrors of a particular web resource, something like a per-directory <span class="caps">MIRROR</span> file (in <span class="caps">XML</span>).  A local web-proxy/daemon would cache the status, speed, and locality of various mirrors, and attempt to provide the best location for a particular resource (Use Case #1: Linux <span class="caps">RPM</span> repositories).  Throw in resource discovery, and you have a basic peer-to-peer network, all over <span class="caps">HTTP</span>.  While this project assumes that each peer is serving <span class="caps">OFF</span>-encoded blocks, there&#8217;s no reason why this assumption couldn&#8217;t be refactored-out, leaving a generic <span class="caps">HTTP</span> P2P system.</p>
<p>To date I&#8217;ve already completed most of the functionality of <span class="caps">ODIN</span>: fast block encoding (more on that later), file insertion and extraction, basic file transfer and peer discovery.  I&#8217;ll post more when I have something to show-off. ;)</p>
<h3>Prototyping</h3>
<p>My first attempt at a routine to <span class="caps">XOR</span> blocks (stored as Strings) looked something like this:</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="nf">xor!</span><span class="p">(</span> <span class="n">str1</span><span class="p">,</span> <span class="n">str2</span> <span class="p">)</span>
    <span class="no">BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">128</span><span class="p">.</span><span class="nf">kilobytes</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="no">BLOCK_SIZE</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure><p>There may very well be a faster way of doing this in pure Ruby, but I couldn&#8217;t find it (and didn&#8217;t want to waste the time).  This worked well enough to finish the basic implementation and unit tests.  And even though this prototype version was way too slow, it allowed me to build-out the higher-level code and tests so that went I went to replace it with the faster version, I had already established extensive code coverage (which revealed several bugs in my optimized implementation).  Once the prototype is complete it&#8217;s time for &#8230;</p>
<h3>Profiling</h3>
<blockquote>
<p>Premature optimization is the root of all evil.<br/>
- Donald Knuth</p>
</blockquote>
<p>Even though I knew that <span class="caps">XOR</span> was going to be the biggest cycle-sink, I decided that now would be a good time to learn about Ruby profiling.  <a href="http://ruby-prof.rubyforge.org/">ruby-prof</a> makes this fairly easy.  I chose my biggest, most involved unit test, and wrapped it like so:</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'ruby-prof'</span>
<span class="k">def</span> <span class="nf">profile_lotsofstuff</span>
  <span class="n">res</span> <span class="o">=</span> <span class="no">RubyProf</span><span class="p">.</span><span class="nf">profile</span> <span class="k">do</span>
    <span class="n">test_lotsofstuff</span>
  <span class="k">end</span>
  <span class="no">RubyProf</span><span class="o">::</span><span class="no">GraphPrinter</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">res</span><span class="p">).</span><span class="nf">print</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
<span class="kp">alias_method</span> <span class="ss">:test_profile_lotsofstuff</span><span class="p">,</span> <span class="ss">:profile_lotsofstuff</span>   <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'PROFILE'</span><span class="p">]</span></code></pre></figure><p>This allows me to easily profile by running that unit test from the command line:</p>
<figure class="highlight"><pre><code class="language-sh" data-lang="sh">clear <span class="p">;</span> <span class="nv">PROFILE</span><span class="o">=</span>1 ruby <span class="nb">test</span>/unit/stuff_test.rb</code></pre></figure><p>While I&#8217;m still working on tweaking the various output parameters, the result did confirm my suspicions:</p>
<pre>
  %total   %self     total      self    children             calls   Name
--------------------------------------------------------------------------------
                      8.04      4.97      3.07                 4/4     String#xor!
  96.87%  59.88%      8.04      4.97      3.07                   4     Range#each
                      1.07      1.07      0.00     1048576/1048576     Fixnum#^
                      1.53      1.53      0.00     1572864/1572880     String#[]
                      0.47      0.47      0.00       524288/524288     String#[]=

</pre>
<h3>Extending with C</h3>
<p>Especially for tight nested loops like this, you quickly take a bit performance hit just from the loop overhead.  In this case, I also couldn&#8217;t find an easy way to iterate through two strings simultaneously.  After a while, it became quite annoying knowing that I could do the whole thing in a short little C function.</p>
<p>So that&#8217;s what I did.  I created a small Rails plugin (<code>xor</code>), with appropriate <code>init.rb</code>, and added a <code>lib/xor.c</code> that looks something like:</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="n">VALUE</span> <span class="nf">string_xor</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">VALUE</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">self</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src1</span> <span class="o">=</span> <span class="n">STR2CSTR</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src2</span> <span class="o">=</span> <span class="n">STR2CSTR</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">STR2CSTR</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">RSTRING</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">len</span><span class="o">--</span><span class="p">;</span> <span class="o">++</span><span class="n">dest</span><span class="p">,</span> <span class="o">++</span><span class="n">src1</span><span class="p">,</span> <span class="o">++</span><span class="n">src2</span> <span class="p">)</span>
    <span class="o">*</span><span class="n">dest</span> <span class="o">^=</span> <span class="o">*</span><span class="n">src</span> <span class="o">^</span> <span class="o">*</span><span class="n">src2</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Init_xor</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">rb_define_method</span><span class="p">(</span> <span class="n">rb_cString</span><span class="p">,</span> <span class="s">"xor!"</span><span class="p">,</span> <span class="p">((</span><span class="n">VALUE</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">ANYARGS</span><span class="p">))</span> <span class="n">string_xor</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span></code></pre></figure><p>Using the <a href="onebananaproblem.com/articles/2006/09/09/ruby-extensions-with-rake">Rake task for Ruby extensions</a>  from my <a href="http:rubyforge.org/projects/rdbxml"><span class="caps">RDBXML</span></a> project makes it trivial to build with a small Rakefile:</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'rake/extensiontask'</span>
<span class="n">desc</span> <span class="s2">"Build the XOR extension"</span>
<span class="no">Rake</span><span class="o">::</span><span class="no">ExtensionTask</span><span class="p">.</span><span class="nf">new</span> <span class="ss">:xor</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
  <span class="n">t</span><span class="p">.</span><span class="nf">dir</span> <span class="o">=</span> <span class="s1">'lib'</span>
<span class="k">end</span></code></pre></figure><p>Added some test cases for the various <span class="caps">XOR</span> identities (e.g. <code>x^0 = x</code>, <code>x^x = 0</code>, etc.) and that was it.  I kept the pure Ruby version of the function for later (renamed to <code>slow_xor!</code>).</p>
<h3>Benchmarking</h3>
<p>A few runs through the higher-level tests show a <strong>huge</strong> improvement in speed.  But just how much is that?  It&#8217;s easy to tell with Ruby&#8217;s built-in benchmarking support.  As with the profiling, I find it convenient to hack it onto the existing unit tests, as they already prove a good source of stress-tests.</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">benchmark_xor</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="no">Benchmark</span><span class="p">.</span><span class="nf">bm</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">bm</span><span class="o">|</span>
      <span class="n">bm</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span> <span class="s2">"XOR (c) :"</span> <span class="p">)</span> <span class="p">{</span>  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">test_xor</span> <span class="p">}</span>  <span class="p">}</span>
      <span class="no">String</span><span class="p">.</span><span class="nf">module_eval</span> <span class="p">{</span> <span class="kp">alias_method</span> <span class="ss">:xor!</span><span class="p">,</span> <span class="ss">:slow_xor!</span> <span class="p">}</span>
      <span class="n">bm</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span> <span class="s2">"XOR (rb):"</span> <span class="p">)</span> <span class="p">{</span>  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">test_xor</span> <span class="p">}</span>  <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="kp">alias_method</span> <span class="ss">:test_benchmark_xor</span><span class="p">,</span> <span class="ss">:benchmark_xor</span>  <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'BENCHMARK'</span><span class="p">]</span></code></pre></figure><pre>              user     system      total        real
XOR (c) :  1.200000   0.116667   1.316667 (  0.817143)
XOR (rb): 81.433333   0.683333  82.116667 ( 50.567826)
</pre>
<p>This shows a speed-up of a little over 60&#215;.    This changes the execution times for just about every operation from &#8220;minutes&#8221; into &#8220;seconds&#8221;.  Not bad, eh?</p>
<blockquote>
<p>Your Milleage May Vary</p>
</blockquote>
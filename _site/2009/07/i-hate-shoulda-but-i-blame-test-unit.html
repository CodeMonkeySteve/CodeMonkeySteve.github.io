<p>I hate Shoulda.</p>
<p>But I blame Test::Unit.</p>
<p>Because Test::Unit can&#8217;t scale.</p>
<p>There, I&#8217;ve said it. It wasn&#8217;t easy, I drank the <a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="caps">TDD</span></a> Cool-Aid a long time ago, and never looked back.  But the fact of the matter is that <a href="http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/classes/Test/Unit.html">Test::Unit</a> is rotten from the very core, and it makes the seductive <a href="http://thoughtbot.com/projects/shoulda">Shoulda</a> features nothing but bitter lies.  Let me demonstrate:</p>
<h2>Hopeful Optimism</h2>
<p>Take a sufficiently-contrived test, where you create some object and verify some of its properties:</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'test/unit'</span>
<span class="nb">require</span> <span class="s1">'shoulda'</span>

<span class="k">class</span> <span class="nc">Numeric</span>
  <span class="k">def</span> <span class="nf">even?</span> <span class="p">;</span> <span class="p">(</span><span class="nb">self</span> <span class="o">%</span> <span class="mi">2</span><span class="p">).</span><span class="nf">zero?</span>    <span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">odd?</span>  <span class="p">;</span> <span class="p">(</span><span class="nb">self</span> <span class="o">%</span> <span class="mi">2</span><span class="p">).</span><span class="nf">nonzero?</span> <span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">OddNumberTest</span> <span class="o">&lt;</span> <span class="no">Test</span><span class="o">::</span><span class="no">Unit</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="n">context</span> <span class="s1">'an odd number'</span>  <span class="k">do</span>
    <span class="n">setup</span> <span class="k">do</span>
      <span class="c1"># create object</span>
      <span class="vi">@n</span> <span class="o">=</span> <span class="mi">97</span> <span class="p">;</span> <span class="nb">sleep</span> <span class="mi">1</span>
    <span class="k">end</span>

    <span class="n">should</span><span class="p">(</span><span class="s1">'be true'</span><span class="p">)</span>     <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span>        <span class="p">}</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'be odd'</span><span class="p">)</span>      <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>   <span class="p">}</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'not be even'</span><span class="p">)</span> <span class="p">{</span>  <span class="n">assert</span> <span class="o">!</span><span class="vi">@n</span><span class="p">.</span><span class="nf">even?</span>  <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure><p>Now, someone naive in the ways of Test::Unit, might expect this test to take approximately <em>one second</em> to execute, right?  After all, it&#8217;s only the object creation that takes any time (in these examples, the <code>sleep 1</code> represents some non-trivial database or network operation).  So we run it, and &#8230;</p>
<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">$ </span>ruby <span class="nt">-rubygems</span> ./why_shoulda_sucks.rb
Loaded suite why_shoulda_sucks
Started
...
Finished <span class="k">in </span>3.006617 seconds.
3 tests, 3 assertions, 0 failures, 0 errors</code></pre></figure><p>&#8220;<strong>Three seconds</strong>?  Why did it take so long?!&#8221;, our poor naive tester cries.  Because, expecting Shoulda to act like a Domain-Specific Language (as all Right-Thinking Rubyists would), he doesn&#8217;t realize that under the covers it&#8217;s just creating three different Test::Unit tests.  So what&#8217;s so bad about Test::Unit?</p>
<h2>A Sense of Dread</h2>
<p>What&#8217;s so bad about Test::Unit is that it makes the following assumptions:</p>
<ul>
	<li>Each test may be run in any order, not the order define (in fact, it&#8217;s in sorted order by test name)</li>
	<li>Each test may modify the state at any time, not just in the <code>setup</code> function</li>
</ul>
<p>Therefore, the <code>setup</code> (and <code>teardown</code>) functions must be called <strong>for every test</strong>, whether they really need it or not.</p>
<p>So instead of:</p>
<ol>
	<li>setup</li>
	<li>should be true</li>
	<li>should be odd</li>
	<li>should not be even</li>
	<li>(teardown)</li>
</ol>
<p>We get:</p>
<ol>
	<li>setup</li>
	<li>should be true</li>
	<li>(teardown)</li>
	<li>(setup)</li>
	<li>should be odd</li>
	<li>(teardown)</li>
	<li>(setup)</li>
	<li>should not be even</li>
	<li>(teardown)</li>
	<li>(setup)</li>
</ol>
<p>That&#8217;s a lot of extraneous setting-up and tearing-down, and since those are the parts that actually do stuff (as opposed to the assertions themselves), that&#8217;s the slowest part of the test.</p>
<h2>Crushing Disappointment</h2>
<p>The greatest features in Shoulda (as opposed to, say, <a href="http://rspec.info/">RSpec</a>) is the ability to use <em>nested contexts</em>.  This lets us do sub-tests that inherit their parent context&#8217;s state, but roll-back their own changes.  So let&#8217;s add one:</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">OddNumberTest</span> <span class="o">&lt;</span> <span class="no">Test</span><span class="o">::</span><span class="no">Unit</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="n">context</span> <span class="s1">'an odd number'</span>  <span class="k">do</span>
    <span class="n">setup</span> <span class="k">do</span>
      <span class="c1"># create object</span>
      <span class="vi">@n</span> <span class="o">=</span> <span class="mi">97</span> <span class="p">;</span> <span class="nb">sleep</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'be true'</span><span class="p">)</span>     <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span>        <span class="p">}</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'be odd'</span><span class="p">)</span>      <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>   <span class="p">}</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'not be even'</span><span class="p">)</span> <span class="p">{</span>  <span class="n">assert</span> <span class="o">!</span><span class="vi">@n</span><span class="p">.</span><span class="nf">even?</span>  <span class="p">}</span>

    <span class="n">context</span> <span class="s1">'add one'</span> <span class="k">do</span>
      <span class="n">setup</span> <span class="k">do</span>
        <span class="c1"># modify object</span>
        <span class="vi">@n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nb">sleep</span> <span class="mi">1</span>
      <span class="k">end</span>
      <span class="n">should</span><span class="p">(</span><span class="s1">'be true'</span><span class="p">)</span>    <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span>        <span class="p">}</span>
      <span class="n">should</span><span class="p">(</span><span class="s1">'be even'</span><span class="p">)</span>    <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span><span class="p">.</span><span class="nf">even?</span>  <span class="p">}</span>
      <span class="n">should</span><span class="p">(</span><span class="s1">'not be odd'</span><span class="p">)</span> <span class="p">{</span>  <span class="n">assert</span> <span class="o">!</span><span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>   <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">should</span><span class="p">(</span><span class="s1">'still be odd'</span><span class="p">)</span>  <span class="p">{</span>  <span class="n">assert</span> <span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>  <span class="p">}</span>
  <span class="k">end</span></code></pre></figure><p>Again, on first glance you might expect this test to take <em>two seconds</em>, but actually:</p>
<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">$ </span>ruby <span class="nt">-rubygems</span> ./why_shoulda_sucks.rb
Loaded suite why_shoulda_sucks
Started
.......
Finished <span class="k">in </span>10.014666 seconds.
7 tests, 7 assertions, 0 failures, 0 errors</code></pre></figure><p><strong>Ten seconds</strong>, over <strong>five times</strong> what it really should be if Test::Unit was just smart enough execute the tests in the order given, and perform the <code>setup</code> and <code>teardown</code> appropriately.</p>
<h2>The Test::Unit <a href="http://en.wikipedia.org/wiki/Fail_whale">Fail Whale</a></h2>
<p>And that&#8217;s just with one level of nesting.  If we try an even slight-complicated test, with several contexts nested even only a few deep:</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">OddNumberTest</span> <span class="o">&lt;</span> <span class="no">Test</span><span class="o">::</span><span class="no">Unit</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="n">context</span> <span class="s1">'an odd number'</span>  <span class="k">do</span>
    <span class="n">setup</span> <span class="k">do</span>
      <span class="c1"># create object</span>
      <span class="vi">@n</span> <span class="o">=</span> <span class="mi">97</span> <span class="p">;</span> <span class="nb">sleep</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'be true'</span><span class="p">)</span>     <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span>        <span class="p">}</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'be odd'</span><span class="p">)</span>      <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>   <span class="p">}</span>
    <span class="n">should</span><span class="p">(</span><span class="s1">'not be even'</span><span class="p">)</span> <span class="p">{</span>  <span class="n">assert</span> <span class="o">!</span><span class="vi">@n</span><span class="p">.</span><span class="nf">even?</span>  <span class="p">}</span>

    <span class="n">context</span> <span class="s1">'add one'</span> <span class="k">do</span>
      <span class="n">setup</span> <span class="k">do</span>
        <span class="c1"># modify object</span>
        <span class="vi">@n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nb">sleep</span> <span class="mi">1</span>
      <span class="k">end</span>
      <span class="n">should</span><span class="p">(</span><span class="s1">'be true'</span><span class="p">)</span>    <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span>        <span class="p">}</span>
      <span class="n">should</span><span class="p">(</span><span class="s1">'be even'</span><span class="p">)</span>    <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span><span class="p">.</span><span class="nf">even?</span>   <span class="p">}</span>
      <span class="n">should</span><span class="p">(</span><span class="s1">'not be odd'</span><span class="p">)</span> <span class="p">{</span>  <span class="n">assert</span> <span class="o">!</span><span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>  <span class="p">}</span>

      <span class="n">context</span> <span class="s1">'subtract one'</span> <span class="k">do</span>
        <span class="n">setup</span> <span class="k">do</span>
          <span class="c1"># modify object</span>
          <span class="vi">@n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="p">;</span> <span class="nb">sleep</span> <span class="mi">1</span>
        <span class="k">end</span>
        <span class="n">should</span><span class="p">(</span><span class="s1">'be true'</span><span class="p">)</span>     <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span>        <span class="p">}</span>
        <span class="n">should</span><span class="p">(</span><span class="s1">'be odd'</span><span class="p">)</span>      <span class="p">{</span>  <span class="n">assert</span>  <span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>   <span class="p">}</span>
        <span class="n">should</span><span class="p">(</span><span class="s1">'not be even'</span><span class="p">)</span> <span class="p">{</span>  <span class="n">assert</span> <span class="o">!</span><span class="vi">@n</span><span class="p">.</span><span class="nf">even?</span>  <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">should</span><span class="p">(</span><span class="s1">'still be odd'</span><span class="p">)</span>  <span class="p">{</span>  <span class="n">assert</span> <span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>  <span class="p">}</span>

    <span class="n">context</span> <span class="s1">'multiply by two'</span> <span class="k">do</span>
      <span class="n">setup</span> <span class="k">do</span>
        <span class="c1"># modify object</span>
        <span class="vi">@n</span> <span class="o">*=</span> <span class="mi">2</span> <span class="p">;</span> <span class="nb">sleep</span> <span class="mi">1</span>
      <span class="k">end</span>
      <span class="n">should</span> <span class="s1">'be true'</span>    <span class="k">do</span>  <span class="n">assert</span>  <span class="vi">@n</span>        <span class="k">end</span>
      <span class="n">should</span> <span class="s1">'be even'</span>    <span class="k">do</span>  <span class="n">assert</span>  <span class="vi">@n</span><span class="p">.</span><span class="nf">even?</span>  <span class="k">end</span>
      <span class="n">should</span> <span class="s1">'not be odd'</span> <span class="k">do</span>  <span class="n">assert</span> <span class="o">!</span><span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>   <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">should</span><span class="p">(</span><span class="s1">'even still be odd'</span><span class="p">)</span>  <span class="p">{</span>  <span class="n">assert</span> <span class="vi">@n</span><span class="p">.</span><span class="nf">odd?</span>  <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure><p>Can you say &#8220;exponential growth&#8221;?</p>
<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">$ </span>ruby <span class="nt">-rubygems</span> ./why_shoulda_sucks.rb
Loaded suite why_shoulda_sucks
Started
.......
Finished <span class="k">in </span>26.048316 seconds.
14 tests, 14 assertions, 0 failures, 0 errors</code></pre></figure><p><strong>26 seconds</strong>, that&#8217;s <strong>six times</strong> longer than it should take.</p>
<h2>You Think That&#8217;s Bad?</h2>
<p>Now that I&#8217;m working at a Real Ruby Shop, I&#8217;ve gotten to experience the joy of having thousands of tests to make sure I haven&#8217;t done something stupid.  But I also get to experience the pain of running all these tests under this profoundly inefficient framework:</p>
<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">$ </span>rake <span class="nb">test</span>:units <span class="nb">test</span>:functionals <span class="nb">test</span>:integration
Finished <span class="k">in </span>1042.379506 seconds.
2141 tests, 4576 assertions, 0 failures, 0 errors

Finished <span class="k">in </span>578.284529 seconds.
613 tests, 896 assertions, 0 failures, 0 errors

Finished <span class="k">in </span>34.538012 seconds.
22 tests, 65 assertions, 0 failures, 0 errors</code></pre></figure><p>Almost <strong>half an hour</strong> on a decent system, <strong>over 50 minutes</strong> on our Continuous Integration server.  That&#8217;s an awful lot of waiting.</p>
<h2>Screw You Guys, I&#8217;m Going Home</h2>
<p><a href="http://rubyrags.com/products/10">Fork You</a> then, I&#8217;ll make my own testing framework that keeps track of dependencies and instantiates them in the most efficient way (<a href="http://www.mahalo.com/bender-quotes">and blackjack, and hookers!</a>) .  And while I&#8217;m at it:</p>
<ul>
	<li>&#8220;Should&#8221; is <a href="http://www.faqs.org/rfcs/rfc2119.html">not the correct word</a> .  &#8220;Must&#8221; is the correct word (plus, less typing).</li>
	<li>If a test fails, it should not run any other tests in that context.  They&#8217;ll almost certainly also fail and unhelpfully spam you with error messages.</li>
	<li><a href="http://www.faqs.org/rfcs/rfc2119.html">Autotest</a> should be baked right in, so that if a subset of the tests fail, I should be able to re-run just the failing tests, which will in turn only instantiate the necessary prerequisites, and in the most efficient order.</li>
</ul>
<p>So far I have a proof-of-concept project on GitHub called <a href="http://github.com/CodeMonkeySteve/mustard">Mustard</a> .  I&#8217;m going to start migrating my other projects to it from Shoulda and will write more on the subject later.  Watch this space &#8230;</p>
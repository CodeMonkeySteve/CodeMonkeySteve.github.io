<p>Here&#8217;s a tip so simple and elegant it&#8217;s amazing I ever got along without it.  Consider <code>String#to_f</code>:</p>
<figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">--&gt; '12.34'.to_f
==&gt; 12.34</span></code></pre></figure><p>Which works great, so long as the string is a valid number, but if not:</p>
<figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">--&gt; 'splat'.to_f
==&gt; 0.0</span></code></pre></figure><p><code>#to_f</code> doesn&#8217;t throw an exception with invalid input, making it dangerous to use with any user-supplied data.  I&#8217;ve seen various solutions that involve regular expressions, but these are kludgy and don&#8217;t handle all proper numeric representations.</p>
<p>Fortunately, Ruby provides type-cast-style methods to do proper conversions with validation:</p>
<figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">--&gt; Float('12.34')
==&gt; 12.34
--&gt; Float('splat')
</span><span class="gr">ArgumentError: invalid value for Float(): "splat"</span></code></pre></figure><p>It might look weird, until you realize that <code>Float</code> is both a class (<code>::Float</code>) and a kernel method (<code>Kernel.Float</code>).  There are also methods for converting to an <code>Integer</code>, <code>Array</code>, or even back to a <code>String</code> (which is essentially just <code>#to_s</code>).</p>